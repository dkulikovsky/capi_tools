// Code generated by protoc-gen-go.
// source: clusterapi/clusterapi.proto
// DO NOT EDIT!

/*
Package clusterapi is a generated protocol buffer package.

It is generated from these files:
	clusterapi/clusterapi.proto

It has these top-level messages:
	ApplyGroupTransitionRequest
	GroupTransition
	Transition
	GetStateRequest
	GetStateDeltaRequest
	DestroyRequest
	DestroyGroupRequest
	Owner
	SchedulerSignature
	ApplyGroupTransitionResponse
	ApplyGroupEither
	DestroyResponse
	DestroyGroupEither
	ClusterState
	ClusterStateDelta
	ClusterVersion
	HostMetadata
	Host
	Location
	HostHealth
	Workload
	Entity
	ComputingResources
	GpuSet
	GpuSlot
	Ports
	NamedCountable
	Exception
	ApplyIllegalStateException
	EtagFailureException
	GroupTransitionApplyException
	HostNotInClusterException
	HostOvercommittedException
	TransitionValidationException
	QuotaViolationException
	HostTransitionApplyException
	SystemException
	Instance
	Job
	TimeLimit
	Container
	WorkloadId
	Slot
	ConfigurationId
	Volume
	Resourcelike
	Resource
	DynamicResource
	Verification
	Shard
	TrafficClass
	DetailedCurrentState
	CurrentStateFeedback
	FeedbackMessage
	FeedbackFailMessage
	HookInProgress
	CountersFeedback
	FeedbackMergeMessage
	FeedbackOkMessage
	Progress
	Lock
	ProcessFeedback
	SelfHelp
	ChecksumVerificationFailure
	ChecksumProgress
	DaemonFailure
	DownloadFailed
	ResourcesNotReady
	ValidationFailed
	DirectoryFailure
	CachedResourceNotRemoved
	WaitingForFreeSpace
	HookFailure
	CountLimit
	FrequencyLimit
	PendingDriverRemove
	TimeLimitViolation
	ShardFailure
	QueueControl
	ToAgent
	ToServer
	HostConfiguration
	HostConfigurationInstance
	AgentHandshake
	KeepAlive
*/
package clusterapi

import proto "github.com/golang/protobuf/proto"
import "github.com/golang/protobuf/protoc-gen-go/descriptor"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal

type FilterType int32

const (
	FilterType_NONE     FilterType = 0
	FilterType_HOST     FilterType = 1
	FilterType_WORKLOAD FilterType = 2
)

var FilterType_name = map[int32]string{
	0: "NONE",
	1: "HOST",
	2: "WORKLOAD",
}
var FilterType_value = map[string]int32{
	"NONE":     0,
	"HOST":     1,
	"WORKLOAD": 2,
}

func (x FilterType) String() string {
	return proto.EnumName(FilterType_name, int32(x))
}

type HostHealthState int32

const (
	// Хост не работает
	HostHealthState_DOWN HostHealthState = 0
	// Хост работает, можно планировать на него задачи
	HostHealthState_UP HostHealthState = 1
	// Начальное состояние, хост нельзя использовать.
	// Wall-E реагирует на появление таких хостов, переводит в их MAINTENANCE и наливает кошерными версиями софта.
	HostHealthState_INITIAL HostHealthState = 2
	// Всякие работы с хостом, переналивки, установки софта и т.п. После этого хост переходит в PROBATION.
	HostHealthState_MAINTENANCE HostHealthState = 3
	// Prestable-планировщик запускает тесты на таких хостах. По сообщению от prestable-планировщика или по
	// истечению TTL хост переходит в UP.
	HostHealthState_PROBATION HostHealthState = 4
	// Планировщики должны понимать, что скоро хост уйдет и не следует на него планировать. Переводим в
	// MAINTENANCE либо когда мешающих джобов на хосте больше нет, либо по TTL.
	HostHealthState_PREPARE_MAINTENANCE HostHealthState = 5
)

var HostHealthState_name = map[int32]string{
	0: "DOWN",
	1: "UP",
	2: "INITIAL",
	3: "MAINTENANCE",
	4: "PROBATION",
	5: "PREPARE_MAINTENANCE",
}
var HostHealthState_value = map[string]int32{
	"DOWN":                0,
	"UP":                  1,
	"INITIAL":             2,
	"MAINTENANCE":         3,
	"PROBATION":           4,
	"PREPARE_MAINTENANCE": 5,
}

func (x HostHealthState) String() string {
	return proto.EnumName(HostHealthState_name, int32(x))
}

// Версия архитектуры
// В описании хоста обозначает версию конкретной карты
// В описании задачи - минимальную подходящую версию
// ANY удовлетворяет любая карта
// CUDA_ANY - любая карта с CUDA
// CUDA_<версия> - любая карта с указанной или большей версией
type GpuType int32

const (
	GpuType_ANY      GpuType = 0
	GpuType_CUDA_ANY GpuType = 1
	GpuType_CUDA_2_0 GpuType = 2
	GpuType_CUDA_2_1 GpuType = 3
	GpuType_CUDA_3_0 GpuType = 4
	GpuType_CUDA_3_2 GpuType = 5
	GpuType_CUDA_3_5 GpuType = 6
	GpuType_CUDA_3_7 GpuType = 7
	GpuType_CUDA_5_0 GpuType = 8
	GpuType_CUDA_5_2 GpuType = 9
)

var GpuType_name = map[int32]string{
	0: "ANY",
	1: "CUDA_ANY",
	2: "CUDA_2_0",
	3: "CUDA_2_1",
	4: "CUDA_3_0",
	5: "CUDA_3_2",
	6: "CUDA_3_5",
	7: "CUDA_3_7",
	8: "CUDA_5_0",
	9: "CUDA_5_2",
}
var GpuType_value = map[string]int32{
	"ANY":      0,
	"CUDA_ANY": 1,
	"CUDA_2_0": 2,
	"CUDA_2_1": 3,
	"CUDA_3_0": 4,
	"CUDA_3_2": 5,
	"CUDA_3_5": 6,
	"CUDA_3_7": 7,
	"CUDA_5_0": 8,
	"CUDA_5_2": 9,
}

func (x GpuType) String() string {
	return proto.EnumName(GpuType_name, int32(x))
}

type DeduplicationMode int32

const (
	// На одинаковые файлы будут создаваться жесткие ссылки. Режим по умолчанию.
	DeduplicationMode_HARDLINK DeduplicationMode = 0
	// Не дедуплицировать.
	DeduplicationMode_NO DeduplicationMode = 1
	// На одинаковые файлы будут создаваться символьные ссылки.
	DeduplicationMode_SYMLINK DeduplicationMode = 2
)

var DeduplicationMode_name = map[int32]string{
	0: "HARDLINK",
	1: "NO",
	2: "SYMLINK",
}
var DeduplicationMode_value = map[string]int32{
	"HARDLINK": 0,
	"NO":       1,
	"SYMLINK":  2,
}

func (x DeduplicationMode) String() string {
	return proto.EnumName(DeduplicationMode_name, int32(x))
}

// Аргумент applyGroupTransition
type ApplyGroupTransitionRequest struct {
	GroupTransitions   []*GroupTransition  `protobuf:"bytes,1,rep,name=groupTransitions" json:"groupTransitions,omitempty"`
	SchedulerSignature *SchedulerSignature `protobuf:"bytes,2,opt,name=schedulerSignature" json:"schedulerSignature,omitempty"`
}

func (m *ApplyGroupTransitionRequest) Reset()         { *m = ApplyGroupTransitionRequest{} }
func (m *ApplyGroupTransitionRequest) String() string { return proto.CompactTextString(m) }
func (*ApplyGroupTransitionRequest) ProtoMessage()    {}

func (m *ApplyGroupTransitionRequest) GetGroupTransitions() []*GroupTransition {
	if m != nil {
		return m.GroupTransitions
	}
	return nil
}

func (m *ApplyGroupTransitionRequest) GetSchedulerSignature() *SchedulerSignature {
	if m != nil {
		return m.SchedulerSignature
	}
	return nil
}

// Целевое состояние группы задач
// CAPI будет приводить группу к описанному состоянию, в том числе изменяя состяние и удаляя ранее запущенные задачи группы,
// если их указанное состояние отличается от текущего состояния на кластере
type GroupTransition struct {
	// Идентификатор группы задач. Запросы с одинаковым идентификатором будут применяться к одной и той же группе.
	GroupId string `protobuf:"bytes,1,opt,name=groupId" json:"groupId,omitempty"`
	// Автор запроса, для него будет проверяться права/квоты
	Owner *Owner `protobuf:"bytes,2,opt,name=owner" json:"owner,omitempty"`
	// Описания задач группы на отдельных хостах
	Transitions []*Transition `protobuf:"bytes,3,rep,name=transitions" json:"transitions,omitempty"`
	// Уникальный идентификатор конкретной операции для логирования/отладки
	GroupOperationId string `protobuf:"bytes,4,opt,name=groupOperationId" json:"groupOperationId,omitempty"`
}

func (m *GroupTransition) Reset()         { *m = GroupTransition{} }
func (m *GroupTransition) String() string { return proto.CompactTextString(m) }
func (*GroupTransition) ProtoMessage()    {}

func (m *GroupTransition) GetOwner() *Owner {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *GroupTransition) GetTransitions() []*Transition {
	if m != nil {
		return m.Transitions
	}
	return nil
}

// Список задач на хосте в рамках группы задач.
// Обязательно следует передавать все задачи группы, в том числе и те, в которые не вносились изменения с предыдущего запроса.
// Задачи, состояние которых не соответствует указанному, будут изменены/удалены.
type Transition struct {
	HostId string `protobuf:"bytes,1,opt,name=hostId" json:"hostId,omitempty"`
	// etag состояния хоста, на основании которого осуществлялось планирование
	HostStateEtag int64       `protobuf:"varint,2,opt,name=hostStateEtag" json:"hostStateEtag,omitempty"`
	Workloads     []*Workload `protobuf:"bytes,3,rep,name=workloads" json:"workloads,omitempty"`
}

func (m *Transition) Reset()         { *m = Transition{} }
func (m *Transition) String() string { return proto.CompactTextString(m) }
func (*Transition) ProtoMessage()    {}

func (m *Transition) GetWorkloads() []*Workload {
	if m != nil {
		return m.Workloads
	}
	return nil
}

// Аргумент getState
type GetStateRequest struct {
	// Версия известного клиенту состояния кластера. Если совпадает с версией на сервере, то последний вернет HTTP 304.
	// Логика аналогична HTTP If-None-Match
	// В случае метакластера возвращается 304 только в случае совпадения всех версий подкластеров.
	PreviousVersion *ClusterVersion `protobuf:"bytes,1,opt,name=previousVersion" json:"previousVersion,omitempty"`
	// Фильтр возвращаемых хостов. См. https://wiki.yandex-team.ru/clusterapi/clusterapifilters/#grammatikafiltrov
	HostFilter string `protobuf:"bytes,2,opt,name=hostFilter" json:"hostFilter,omitempty"`
	// Фильтр задач на хостах. См. https://wiki.yandex-team.ru/clusterapi/clusterapifilters/#grammatikafiltrov
	WorkloadFilter string `protobuf:"bytes,3,opt,name=workloadFilter" json:"workloadFilter,omitempty"`
}

func (m *GetStateRequest) Reset()         { *m = GetStateRequest{} }
func (m *GetStateRequest) String() string { return proto.CompactTextString(m) }
func (*GetStateRequest) ProtoMessage()    {}

func (m *GetStateRequest) GetPreviousVersion() *ClusterVersion {
	if m != nil {
		return m.PreviousVersion
	}
	return nil
}

// Аргумент getStateDelta
type GetStateDeltaRequest struct {
	// Версия известного клиенту состояния кластера - относительно нее будут рассчитываться изменения
	FromVersion *ClusterVersion `protobuf:"bytes,1,opt,name=fromVersion" json:"fromVersion,omitempty"`
	// Фильтр возвращаемых хостов
	HostFilter string `protobuf:"bytes,2,opt,name=hostFilter" json:"hostFilter,omitempty"`
	// Фильтр задач на хостах
	WorkloadFilter string `protobuf:"bytes,3,opt,name=workloadFilter" json:"workloadFilter,omitempty"`
	// Триггер, определяющий, какие события включать в ответ.
	// См. https://wiki.yandex-team.ru/clusterapi/clusterapifilters/#grammatikatriggerov
	Trigger string `protobuf:"bytes,4,opt,name=trigger" json:"trigger,omitempty"`
	// Ограничение снизу на количество возвращаемых в запросе сущностей (хостов + задач)
	// В ответе может быть больше сущностей
	WorkloadLowerBound int32 `protobuf:"varint,5,opt,name=workloadLowerBound" json:"workloadLowerBound,omitempty"`
	// Ограничение на время ожидания запроса в миллисекундах
	// Запрос завершается, когда либо набрано требуемое количество изменившихся сущностей, либо истекло время ожидания
	TimeoutMs int32 `protobuf:"varint,6,opt,name=timeoutMs" json:"timeoutMs,omitempty"`
}

func (m *GetStateDeltaRequest) Reset()         { *m = GetStateDeltaRequest{} }
func (m *GetStateDeltaRequest) String() string { return proto.CompactTextString(m) }
func (*GetStateDeltaRequest) ProtoMessage()    {}

func (m *GetStateDeltaRequest) GetFromVersion() *ClusterVersion {
	if m != nil {
		return m.FromVersion
	}
	return nil
}

// Аргумент destroy
type DestroyRequest struct {
	GroupsToDestroy    []*DestroyGroupRequest `protobuf:"bytes,1,rep,name=groupsToDestroy" json:"groupsToDestroy,omitempty"`
	SchedulerSignature *SchedulerSignature    `protobuf:"bytes,2,opt,name=schedulerSignature" json:"schedulerSignature,omitempty"`
}

func (m *DestroyRequest) Reset()         { *m = DestroyRequest{} }
func (m *DestroyRequest) String() string { return proto.CompactTextString(m) }
func (*DestroyRequest) ProtoMessage()    {}

func (m *DestroyRequest) GetGroupsToDestroy() []*DestroyGroupRequest {
	if m != nil {
		return m.GroupsToDestroy
	}
	return nil
}

func (m *DestroyRequest) GetSchedulerSignature() *SchedulerSignature {
	if m != nil {
		return m.SchedulerSignature
	}
	return nil
}

// Запрос на удаление конкретной группы
type DestroyGroupRequest struct {
	GroupId string `protobuf:"bytes,1,opt,name=groupId" json:"groupId,omitempty"`
	// Автор запроса на удаление, для него будут проверяться права/квоты
	Owner *Owner `protobuf:"bytes,2,opt,name=owner" json:"owner,omitempty"`
}

func (m *DestroyGroupRequest) Reset()         { *m = DestroyGroupRequest{} }
func (m *DestroyGroupRequest) String() string { return proto.CompactTextString(m) }
func (*DestroyGroupRequest) ProtoMessage()    {}

func (m *DestroyGroupRequest) GetOwner() *Owner {
	if m != nil {
		return m.Owner
	}
	return nil
}

// Пользователь, от чьего имени задается запрос на изменение кластера
type Owner struct {
	// Идентификатор пользователя
	OwnerId string `protobuf:"bytes,1,opt,name=ownerId" json:"ownerId,omitempty"`
	// Приоритет пользователя в рамках проекта, минимальный приоритет 0 максимальный 1000. Соостветсвенно 1000 - самое приоритетное
	Priority int64 `protobuf:"varint,2,opt,name=priority" json:"priority,omitempty"`
	// Идентификатор проекта, в рамках которого производится запрос
	ProjectId string `protobuf:"bytes,3,opt,name=projectId" json:"projectId,omitempty"`
}

func (m *Owner) Reset()         { *m = Owner{} }
func (m *Owner) String() string { return proto.CompactTextString(m) }
func (*Owner) ProtoMessage()    {}

// Подпись планировщика, пославшего запрос на изменение кластера.
// Для логирования/отладки.
type SchedulerSignature struct {
	// идентификатор планировщика
	SchedulerId string `protobuf:"bytes,1,opt,name=schedulerId" json:"schedulerId,omitempty"`
	// короткое описание, что планировщик собирался сделать
	Message string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *SchedulerSignature) Reset()         { *m = SchedulerSignature{} }
func (m *SchedulerSignature) String() string { return proto.CompactTextString(m) }
func (*SchedulerSignature) ProtoMessage()    {}

// Ответ на applyGroupTransition
type ApplyGroupTransitionResponse struct {
	Results []*ApplyGroupEither `protobuf:"bytes,1,rep,name=results" json:"results,omitempty"`
}

func (m *ApplyGroupTransitionResponse) Reset()         { *m = ApplyGroupTransitionResponse{} }
func (m *ApplyGroupTransitionResponse) String() string { return proto.CompactTextString(m) }
func (*ApplyGroupTransitionResponse) ProtoMessage()    {}

func (m *ApplyGroupTransitionResponse) GetResults() []*ApplyGroupEither {
	if m != nil {
		return m.Results
	}
	return nil
}

// Результат изменения состояния группы. В случае ошибки выставляется поле exception.
// Ошибка означает, что группа осталась в том же состоянии, что и до применения операции.
type ApplyGroupEither struct {
	GroupId   string     `protobuf:"bytes,1,opt,name=groupId" json:"groupId,omitempty"`
	Exception *Exception `protobuf:"bytes,3,opt,name=exception" json:"exception,omitempty"`
}

func (m *ApplyGroupEither) Reset()         { *m = ApplyGroupEither{} }
func (m *ApplyGroupEither) String() string { return proto.CompactTextString(m) }
func (*ApplyGroupEither) ProtoMessage()    {}

func (m *ApplyGroupEither) GetException() *Exception {
	if m != nil {
		return m.Exception
	}
	return nil
}

// Ответ на destroy
type DestroyResponse struct {
	Results []*DestroyGroupEither `protobuf:"bytes,1,rep,name=results" json:"results,omitempty"`
}

func (m *DestroyResponse) Reset()         { *m = DestroyResponse{} }
func (m *DestroyResponse) String() string { return proto.CompactTextString(m) }
func (*DestroyResponse) ProtoMessage()    {}

func (m *DestroyResponse) GetResults() []*DestroyGroupEither {
	if m != nil {
		return m.Results
	}
	return nil
}

// Результат удаления группы. В случае ошибки выставляется поле exception
type DestroyGroupEither struct {
	GroupId   string     `protobuf:"bytes,1,opt,name=groupId" json:"groupId,omitempty"`
	Exception *Exception `protobuf:"bytes,2,opt,name=exception" json:"exception,omitempty"`
}

func (m *DestroyGroupEither) Reset()         { *m = DestroyGroupEither{} }
func (m *DestroyGroupEither) String() string { return proto.CompactTextString(m) }
func (*DestroyGroupEither) ProtoMessage()    {}

func (m *DestroyGroupEither) GetException() *Exception {
	if m != nil {
		return m.Exception
	}
	return nil
}

// Состояние кластера
// Может быть композитом из нескольких кластеров
type ClusterState struct {
	// Хосты с задачами
	Hosts []*Host `protobuf:"bytes,1,rep,name=hosts" json:"hosts,omitempty"`
	// Список хостов, на которые нельзя планировать задачи. TODO: будет удален.
	BannedHosts []string        `protobuf:"bytes,2,rep,name=bannedHosts" json:"bannedHosts,omitempty"`
	Version     *ClusterVersion `protobuf:"bytes,3,opt,name=version" json:"version,omitempty"`
}

func (m *ClusterState) Reset()         { *m = ClusterState{} }
func (m *ClusterState) String() string { return proto.CompactTextString(m) }
func (*ClusterState) ProtoMessage()    {}

func (m *ClusterState) GetHosts() []*Host {
	if m != nil {
		return m.Hosts
	}
	return nil
}

func (m *ClusterState) GetVersion() *ClusterVersion {
	if m != nil {
		return m.Version
	}
	return nil
}

// Изменения между двумя состояниями кластера
type ClusterStateDelta struct {
	// Изменившиеся и созданные проходящие фильтр хосты
	// Здесь только метаинформация о хостах (вычислительные ресурсы, здоровье).
	// Изменения в задачах идут отдельными полями, без привязки к хостам
	ChangedHosts []*HostMetadata `protobuf:"bytes,1,rep,name=changedHosts" json:"changedHosts,omitempty"`
	// Хосты, переставшие проходить фильтр
	FallenOutHosts []*HostMetadata `protobuf:"bytes,2,rep,name=fallenOutHosts" json:"fallenOutHosts,omitempty"`
	// Удаленные хосты, ранее проходившие фильтр
	RemovedHostIds []string `protobuf:"bytes,3,rep,name=removedHostIds" json:"removedHostIds,omitempty"`
	// Изменившиеся и созданные проходящие фильтр задачи
	ChangedWorkloads []*Workload `protobuf:"bytes,4,rep,name=changedWorkloads" json:"changedWorkloads,omitempty"`
	// Задачи, переставшие проходить фильтр
	FallenOutWorkloads []*Workload `protobuf:"bytes,5,rep,name=fallenOutWorkloads" json:"fallenOutWorkloads,omitempty"`
	// Удаленные задачи, ранее проходившие фильтр
	RemovedWorkloadIds []*WorkloadId `protobuf:"bytes,6,rep,name=removedWorkloadIds" json:"removedWorkloadIds,omitempty"`
	// Версия конечного состояния, для которого были посчитаны изменения
	Version *ClusterVersion `protobuf:"bytes,7,opt,name=version" json:"version,omitempty"`
}

func (m *ClusterStateDelta) Reset()         { *m = ClusterStateDelta{} }
func (m *ClusterStateDelta) String() string { return proto.CompactTextString(m) }
func (*ClusterStateDelta) ProtoMessage()    {}

func (m *ClusterStateDelta) GetChangedHosts() []*HostMetadata {
	if m != nil {
		return m.ChangedHosts
	}
	return nil
}

func (m *ClusterStateDelta) GetFallenOutHosts() []*HostMetadata {
	if m != nil {
		return m.FallenOutHosts
	}
	return nil
}

func (m *ClusterStateDelta) GetChangedWorkloads() []*Workload {
	if m != nil {
		return m.ChangedWorkloads
	}
	return nil
}

func (m *ClusterStateDelta) GetFallenOutWorkloads() []*Workload {
	if m != nil {
		return m.FallenOutWorkloads
	}
	return nil
}

func (m *ClusterStateDelta) GetRemovedWorkloadIds() []*WorkloadId {
	if m != nil {
		return m.RemovedWorkloadIds
	}
	return nil
}

func (m *ClusterStateDelta) GetVersion() *ClusterVersion {
	if m != nil {
		return m.Version
	}
	return nil
}

// Версия состояния кластера
// Для атомарного кластера, то есть не разбитого на подкластера, содержит единственную пару <имя> -> <номер версии>.
// Номер версии увеличивается при каждом изменении.
// Может откатиться назад, например, при ручном перезапуске со старым состоянием.
// Для метакластера, т.е. объединения набора кластеров, содержит объединение версий подкластеров.
// Пока что планируется единственный уровень мета-кластера.
type ClusterVersion struct {
	// <имя кластера> -> <версия состояния>
	Versions map[string]uint64 `protobuf:"bytes,1,rep,name=versions" json:"versions,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
}

func (m *ClusterVersion) Reset()         { *m = ClusterVersion{} }
func (m *ClusterVersion) String() string { return proto.CompactTextString(m) }
func (*ClusterVersion) ProtoMessage()    {}

func (m *ClusterVersion) GetVersions() map[string]uint64 {
	if m != nil {
		return m.Versions
	}
	return nil
}

// Метаданные о хосте
type HostMetadata struct {
	// FQDN
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// etag текущего состояния хоста
	Etag int64 `protobuf:"varint,2,opt,name=etag" json:"etag,omitempty"`
	// Полные вычислительные ресурсы хоста
	// Свободные вычислительные ресурсы можно получить вычитанием ресурсов, занятых задачами
	ComputingResources *ComputingResources `protobuf:"bytes,3,opt,name=computingResources" json:"computingResources,omitempty"`
	Health             *HostHealth         `protobuf:"bytes,4,opt,name=health" json:"health,omitempty"`
	Location           *Location           `protobuf:"bytes,5,opt,name=location" json:"location,omitempty"`
}

func (m *HostMetadata) Reset()         { *m = HostMetadata{} }
func (m *HostMetadata) String() string { return proto.CompactTextString(m) }
func (*HostMetadata) ProtoMessage()    {}

func (m *HostMetadata) GetComputingResources() *ComputingResources {
	if m != nil {
		return m.ComputingResources
	}
	return nil
}

func (m *HostMetadata) GetHealth() *HostHealth {
	if m != nil {
		return m.Health
	}
	return nil
}

func (m *HostMetadata) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

// Хост и задачи на нем
type Host struct {
	// Метаданные об этом хосте
	Metadata *HostMetadata `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// Список задач на хосте.
	Workloads []*Workload `protobuf:"bytes,2,rep,name=workloads" json:"workloads,omitempty"`
}

func (m *Host) Reset()         { *m = Host{} }
func (m *Host) String() string { return proto.CompactTextString(m) }
func (*Host) ProtoMessage()    {}

func (m *Host) GetMetadata() *HostMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Host) GetWorkloads() []*Workload {
	if m != nil {
		return m.Workloads
	}
	return nil
}

// Физическое расположение хоста, поля соответствует полям из bot
type Location struct {
	Country  string `protobuf:"bytes,1,opt,name=country" json:"country,omitempty"`
	City     string `protobuf:"bytes,2,opt,name=city" json:"city,omitempty"`
	Building string `protobuf:"bytes,3,opt,name=building" json:"building,omitempty"`
	Line     string `protobuf:"bytes,4,opt,name=line" json:"line,omitempty"`
	Rack     string `protobuf:"bytes,5,opt,name=rack" json:"rack,omitempty"`
	Unit     string `protobuf:"bytes,6,opt,name=unit" json:"unit,omitempty"`
}

func (m *Location) Reset()         { *m = Location{} }
func (m *Location) String() string { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()    {}

// Текущее состояние хоста
type HostHealth struct {
	State HostHealthState `protobuf:"varint,1,opt,name=state,enum=HostHealthState" json:"state,omitempty"`
}

func (m *HostHealth) Reset()         { *m = HostHealth{} }
func (m *HostHealth) String() string { return proto.CompactTextString(m) }
func (*HostHealth) ProtoMessage()    {}

// Выполняемая на хосте задача
// TODO: задачей именуется также Job, нужно разрулить это
type Workload struct {
	// Описание задачи
	Entity *Entity `protobuf:"bytes,1,opt,name=entity" json:"entity,omitempty"`
	// Текущее состояние
	Feedback *DetailedCurrentState `protobuf:"bytes,2,opt,name=feedback" json:"feedback,omitempty"`
	// Создатель задачи
	Owner *Owner `protobuf:"bytes,3,opt,name=owner" json:"owner,omitempty"`
	// Создавший задачу планировщик
	SchedulerId string `protobuf:"bytes,4,opt,name=schedulerId" json:"schedulerId,omitempty"`
	// Пользовательские свойства
	// Пробрасываются хукам через переменные среды
	Properties map[string]string `protobuf:"bytes,5,rep,name=properties" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Id         *WorkloadId       `protobuf:"bytes,6,opt,name=id" json:"id,omitempty"`
	// Целевое состояние - одно из "ACTIVE", "PREPARED", "REMOVED"
	TargetState string `protobuf:"bytes,7,opt,name=targetState" json:"targetState,omitempty"`
	// Момент задания целевого состояния в формате UNIX timestamp
	TransitionTimestamp uint64 `protobuf:"varint,8,opt,name=transitionTimestamp" json:"transitionTimestamp,omitempty"`
	// Поколение Workload в рамках GroupId
	Generation string `protobuf:"bytes,9,opt,name=generation" json:"generation,omitempty"`
}

func (m *Workload) Reset()         { *m = Workload{} }
func (m *Workload) String() string { return proto.CompactTextString(m) }
func (*Workload) ProtoMessage()    {}

func (m *Workload) GetEntity() *Entity {
	if m != nil {
		return m.Entity
	}
	return nil
}

func (m *Workload) GetFeedback() *DetailedCurrentState {
	if m != nil {
		return m.Feedback
	}
	return nil
}

func (m *Workload) GetOwner() *Owner {
	if m != nil {
		return m.Owner
	}
	return nil
}

func (m *Workload) GetProperties() map[string]string {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *Workload) GetId() *WorkloadId {
	if m != nil {
		return m.Id
	}
	return nil
}

type Entity struct {
	Instance *Instance `protobuf:"bytes,1,opt,name=instance" json:"instance,omitempty"`
	Job      *Job      `protobuf:"bytes,2,opt,name=job" json:"job,omitempty"`
}

func (m *Entity) Reset()         { *m = Entity{} }
func (m *Entity) String() string { return proto.CompactTextString(m) }
func (*Entity) ProtoMessage()    {}

func (m *Entity) GetInstance() *Instance {
	if m != nil {
		return m.Instance
	}
	return nil
}

func (m *Entity) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

// Вычислительные ресурсы
type ComputingResources struct {
	// Процессорная мощность в процентах ядра
	// Например, хост с 32 ядрами будет иметь значение 3200
	// Различия в производительности между процессорами никак не учитываются
	// Транслируется в cpu_guarantee
	CpuPowerPercentsCore uint32 `protobuf:"varint,1,opt,name=cpuPowerPercentsCore" json:"cpuPowerPercentsCore,omitempty"`
	// Набор графических карт
	GpuSet *GpuSet `protobuf:"bytes,2,opt,name=gpuSet" json:"gpuSet,omitempty"`
	// Ограничение места на диске в байтах
	// Пока никуда не транслируется =)
	HddSpaceBytes uint64 `protobuf:"varint,3,opt,name=hddSpaceBytes" json:"hddSpaceBytes,omitempty"`
	// Наличие IPv4-интерфейса на хосте
	HasIpv4 bool `protobuf:"varint,4,opt,name=hasIpv4" json:"hasIpv4,omitempty"`
	// Наличие IPv6-интерфейса на хосте
	HasIpv6 bool `protobuf:"varint,5,opt,name=hasIpv6" json:"hasIpv6,omitempty"`
	// Наличие SSD-диска на хосте
	HasSsd bool `protobuf:"varint,6,opt,name=hasSsd" json:"hasSsd,omitempty"`
	// Ограничение на число чтений с диска в секунду
	// Пока никуда не транслируется =)
	IopsRead uint32 `protobuf:"varint,7,opt,name=iopsRead" json:"iopsRead,omitempty"`
	// Ограничение на число записей на диск в секунду
	// Пока никуда не транслируется =)
	IopsWrite uint32 `protobuf:"varint,8,opt,name=iopsWrite" json:"iopsWrite,omitempty"`
	// Ограничение на исходящий сетевой траффик в байтах в секунду
	// Пока никуда не транслируется
	NetworkOutgoingBps uint64 `protobuf:"varint,9,opt,name=networkOutgoingBps" json:"networkOutgoingBps,omitempty"`
	// Порты протокола TCP
	// В описании ресурсов хоста указываются порты, которые могут занимать задачи
	// В задачах - порты, которые требуются им для работы
	PortsTcp *Ports `protobuf:"bytes,10,opt,name=portsTcp" json:"portsTcp,omitempty"`
	// Порты протокола UDP. Аналогично TCP.
	PortsUdp *Ports `protobuf:"bytes,11,opt,name=portsUdp" json:"portsUdp,omitempty"`
	// Ограничение на оперативную память в байтах
	// Транслируется в memory_limit
	RamBytes uint64 `protobuf:"varint,12,opt,name=ramBytes" json:"ramBytes,omitempty"`
	// Произвольные именованные исчислимые ресурсы
	NamedCountables []*NamedCountable `protobuf:"bytes,13,rep,name=namedCountables" json:"namedCountables,omitempty"`
}

func (m *ComputingResources) Reset()         { *m = ComputingResources{} }
func (m *ComputingResources) String() string { return proto.CompactTextString(m) }
func (*ComputingResources) ProtoMessage()    {}

func (m *ComputingResources) GetGpuSet() *GpuSet {
	if m != nil {
		return m.GpuSet
	}
	return nil
}

func (m *ComputingResources) GetPortsTcp() *Ports {
	if m != nil {
		return m.PortsTcp
	}
	return nil
}

func (m *ComputingResources) GetPortsUdp() *Ports {
	if m != nil {
		return m.PortsUdp
	}
	return nil
}

func (m *ComputingResources) GetNamedCountables() []*NamedCountable {
	if m != nil {
		return m.NamedCountables
	}
	return nil
}

type GpuSet struct {
	Slots []*GpuSlot `protobuf:"bytes,1,rep,name=slots" json:"slots,omitempty"`
}

func (m *GpuSet) Reset()         { *m = GpuSet{} }
func (m *GpuSet) String() string { return proto.CompactTextString(m) }
func (*GpuSet) ProtoMessage()    {}

func (m *GpuSet) GetSlots() []*GpuSlot {
	if m != nil {
		return m.Slots
	}
	return nil
}

// Описание графической карты
type GpuSlot struct {
	// Идентификатор на PCI-шине
	GpuId string `protobuf:"bytes,1,opt,name=gpuId" json:"gpuId,omitempty"`
	// Версия архитектуры
	GpuType GpuType `protobuf:"varint,2,opt,name=gpuType,enum=GpuType" json:"gpuType,omitempty"`
	// Число streaming multiprocessors
	// Что-то вроде группы ядер на CPU
	// http://www.informit.com/articles/article.aspx?p=2103809
	SmNumber uint32 `protobuf:"varint,3,opt,name=smNumber" json:"smNumber,omitempty"`
	// Память в мегабайтах
	RamMb uint64 `protobuf:"varint,4,opt,name=ramMb" json:"ramMb,omitempty"`
	// Путь к устройству в системе
	DevicePath string `protobuf:"bytes,5,opt,name=devicePath" json:"devicePath,omitempty"`
}

func (m *GpuSlot) Reset()         { *m = GpuSlot{} }
func (m *GpuSlot) String() string { return proto.CompactTextString(m) }
func (*GpuSlot) ProtoMessage()    {}

// Порты для интернет-протоколов
// Для хоста: capacity - число свободных портов, required - занятые задачами порты
// Для задачи: capacity - число требуемых портов, required - конкретные порты.
// capacity может больше числа портов в required, в этом случае задаче будет назначено
// capacity - required.size() случайных портов (еще не реализовано)
type Ports struct {
	Capacity int32    `protobuf:"varint,1,opt,name=capacity" json:"capacity,omitempty"`
	Required []uint32 `protobuf:"varint,2,rep,name=required" json:"required,omitempty"`
}

func (m *Ports) Reset()         { *m = Ports{} }
func (m *Ports) String() string { return proto.CompactTextString(m) }
func (*Ports) ProtoMessage()    {}

// Любой ресурс, задаваемый в формате <имя> -> <количество>
type NamedCountable struct {
	Name     string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Capacity uint64 `protobuf:"varint,2,opt,name=capacity" json:"capacity,omitempty"`
}

func (m *NamedCountable) Reset()         { *m = NamedCountable{} }
func (m *NamedCountable) String() string { return proto.CompactTextString(m) }
func (*NamedCountable) ProtoMessage()    {}

// Базовый класс исключения
// Все поля, представляющие исключения, должны иметь этот тип, т.к. только он является самодостаточным
// Прочие типы, например, GroupTransitionApplyException, не содержат поля message и имеют смысл только как
// поля внутри Exception
// Если ожидается какой-то специфический тип исключения - нужон делать приведение в пользовательском коде.
// Чтобы восстановить тип исключения, нужно пройти по цепочке oneof derived.
type Exception struct {
	DetailMessage                 string                         `protobuf:"bytes,1,opt,name=detailMessage" json:"detailMessage,omitempty"`
	GroupTransitionApplyException *GroupTransitionApplyException `protobuf:"bytes,2,opt,name=groupTransitionApplyException" json:"groupTransitionApplyException,omitempty"`
	TransitionValidationException *TransitionValidationException `protobuf:"bytes,3,opt,name=transitionValidationException" json:"transitionValidationException,omitempty"`
	SystemException               *SystemException               `protobuf:"bytes,4,opt,name=systemException" json:"systemException,omitempty"`
}

func (m *Exception) Reset()         { *m = Exception{} }
func (m *Exception) String() string { return proto.CompactTextString(m) }
func (*Exception) ProtoMessage()    {}

func (m *Exception) GetGroupTransitionApplyException() *GroupTransitionApplyException {
	if m != nil {
		return m.GroupTransitionApplyException
	}
	return nil
}

func (m *Exception) GetTransitionValidationException() *TransitionValidationException {
	if m != nil {
		return m.TransitionValidationException
	}
	return nil
}

func (m *Exception) GetSystemException() *SystemException {
	if m != nil {
		return m.SystemException
	}
	return nil
}

// Неконсистентные данные в запросе applyGroupTransition
type ApplyIllegalStateException struct {
}

func (m *ApplyIllegalStateException) Reset()         { *m = ApplyIllegalStateException{} }
func (m *ApplyIllegalStateException) String() string { return proto.CompactTextString(m) }
func (*ApplyIllegalStateException) ProtoMessage()    {}

// Изменение группы не прошло, т.к. на каких-то хостах изменились etag'и
type EtagFailureException struct {
}

func (m *EtagFailureException) Reset()         { *m = EtagFailureException{} }
func (m *EtagFailureException) String() string { return proto.CompactTextString(m) }
func (*EtagFailureException) ProtoMessage()    {}

// Ошибка при изменении состояния конкретной группы
type GroupTransitionApplyException struct {
	GroupId string `protobuf:"bytes,1,opt,name=groupId" json:"groupId,omitempty"`
	// Ожидается HostTransitionApplyException, но такой тип поля задать нельзя - см. Exception
	Causes []*Exception `protobuf:"bytes,2,rep,name=causes" json:"causes,omitempty"`
}

func (m *GroupTransitionApplyException) Reset()         { *m = GroupTransitionApplyException{} }
func (m *GroupTransitionApplyException) String() string { return proto.CompactTextString(m) }
func (*GroupTransitionApplyException) ProtoMessage()    {}

func (m *GroupTransitionApplyException) GetCauses() []*Exception {
	if m != nil {
		return m.Causes
	}
	return nil
}

// У CAPI нет информации о хосте
type HostNotInClusterException struct {
}

func (m *HostNotInClusterException) Reset()         { *m = HostNotInClusterException{} }
func (m *HostNotInClusterException) String() string { return proto.CompactTextString(m) }
func (*HostNotInClusterException) ProtoMessage()    {}

// Запрошенные ресурсы не могут быть удовлетворены из свободных ресурсов на хосте
type HostOvercommittedException struct {
	// Список проблем в свободной форме
	Violations []string `protobuf:"bytes,1,rep,name=violations" json:"violations,omitempty"`
}

func (m *HostOvercommittedException) Reset()         { *m = HostOvercommittedException{} }
func (m *HostOvercommittedException) String() string { return proto.CompactTextString(m) }
func (*HostOvercommittedException) ProtoMessage()    {}

// Базовый класс для всех ошибок, возникающих при изменении состояния кластера
type TransitionValidationException struct {
	EtagFailureException         *EtagFailureException         `protobuf:"bytes,1,opt,name=etagFailureException" json:"etagFailureException,omitempty"`
	HostTransitionApplyException *HostTransitionApplyException `protobuf:"bytes,2,opt,name=hostTransitionApplyException" json:"hostTransitionApplyException,omitempty"`
	QuotaViolationException      *QuotaViolationException      `protobuf:"bytes,3,opt,name=quotaViolationException" json:"quotaViolationException,omitempty"`
}

func (m *TransitionValidationException) Reset()         { *m = TransitionValidationException{} }
func (m *TransitionValidationException) String() string { return proto.CompactTextString(m) }
func (*TransitionValidationException) ProtoMessage()    {}

func (m *TransitionValidationException) GetEtagFailureException() *EtagFailureException {
	if m != nil {
		return m.EtagFailureException
	}
	return nil
}

func (m *TransitionValidationException) GetHostTransitionApplyException() *HostTransitionApplyException {
	if m != nil {
		return m.HostTransitionApplyException
	}
	return nil
}

func (m *TransitionValidationException) GetQuotaViolationException() *QuotaViolationException {
	if m != nil {
		return m.QuotaViolationException
	}
	return nil
}

// Автору запроса не хватает прав/квот для выполнения действия
type QuotaViolationException struct {
}

func (m *QuotaViolationException) Reset()         { *m = QuotaViolationException{} }
func (m *QuotaViolationException) String() string { return proto.CompactTextString(m) }
func (*QuotaViolationException) ProtoMessage()    {}

// Ошибка при изменении состояния задач на конкретном хосте
type HostTransitionApplyException struct {
	HostId                     string                      `protobuf:"bytes,1,opt,name=hostId" json:"hostId,omitempty"`
	ApplyIllegalStateException *ApplyIllegalStateException `protobuf:"bytes,2,opt,name=applyIllegalStateException" json:"applyIllegalStateException,omitempty"`
	HostNotInClusterException  *HostNotInClusterException  `protobuf:"bytes,3,opt,name=hostNotInClusterException" json:"hostNotInClusterException,omitempty"`
	HostOvercommittedException *HostOvercommittedException `protobuf:"bytes,4,opt,name=hostOvercommittedException" json:"hostOvercommittedException,omitempty"`
}

func (m *HostTransitionApplyException) Reset()         { *m = HostTransitionApplyException{} }
func (m *HostTransitionApplyException) String() string { return proto.CompactTextString(m) }
func (*HostTransitionApplyException) ProtoMessage()    {}

func (m *HostTransitionApplyException) GetApplyIllegalStateException() *ApplyIllegalStateException {
	if m != nil {
		return m.ApplyIllegalStateException
	}
	return nil
}

func (m *HostTransitionApplyException) GetHostNotInClusterException() *HostNotInClusterException {
	if m != nil {
		return m.HostNotInClusterException
	}
	return nil
}

func (m *HostTransitionApplyException) GetHostOvercommittedException() *HostOvercommittedException {
	if m != nil {
		return m.HostOvercommittedException
	}
	return nil
}

// Любая ошибка на сервере, не попадающая под специфические типы
type SystemException struct {
	// Имя класса исключения
	JavaClass string `protobuf:"bytes,1,opt,name=javaClass" json:"javaClass,omitempty"`
	// Длиннющий стектрейс
	Stacktrace string `protobuf:"bytes,2,opt,name=stacktrace" json:"stacktrace,omitempty"`
}

func (m *SystemException) Reset()         { *m = SystemException{} }
func (m *SystemException) String() string { return proto.CompactTextString(m) }
func (*SystemException) ProtoMessage()    {}

// Демон, он же инстанс - после завершения сущность перезапускается каждый раз, пока не будет удалена с кластера
// Подробнее здесь - https://wiki.yandex-team.ru/iss3/Specifications/configuration/instance/
type Instance struct {
	// Ограничения для всех хуков
	Container *Container `protobuf:"bytes,1,opt,name=container" json:"container,omitempty"`
	Volumes   []*Volume  `protobuf:"bytes,2,rep,name=volumes" json:"volumes,omitempty"`
	// <имя ресурса> -> <описание ресурса>
	Resources map[string]*Resourcelike `protobuf:"bytes,3,rep,name=resources" json:"resources,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// <имя хука> -> <временные лимиты>
	// Имена хуков см https://wiki.yandex-team.ru/iss3/Specifications/configuration/instance/#naznacheniexukov
	TimeLimits map[string]*TimeLimit `protobuf:"bytes,4,rep,name=timeLimits" json:"timeLimits,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Точка монтирования, в которой создается рабочая директория инстанса.
	// По умолчанию - "/".
	Storage string `protobuf:"bytes,5,opt,name=storage" json:"storage,omitempty"`
}

func (m *Instance) Reset()         { *m = Instance{} }
func (m *Instance) String() string { return proto.CompactTextString(m) }
func (*Instance) ProtoMessage()    {}

func (m *Instance) GetContainer() *Container {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *Instance) GetVolumes() []*Volume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *Instance) GetResources() map[string]*Resourcelike {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *Instance) GetTimeLimits() map[string]*TimeLimit {
	if m != nil {
		return m.TimeLimits
	}
	return nil
}

// Задача, она же джоб - выполняется один раз и не перезапускается. Поля те же, что и у демона
// https://wiki.yandex-team.ru/iss3/specifications/configuration/job/
// Поля копируют содержимое Instance на случай будущих изменений, если эти классы разойдутся
type Job struct {
	Container  *Container               `protobuf:"bytes,1,opt,name=container" json:"container,omitempty"`
	Volumes    []*Volume                `protobuf:"bytes,2,rep,name=volumes" json:"volumes,omitempty"`
	Resources  map[string]*Resourcelike `protobuf:"bytes,3,rep,name=resources" json:"resources,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	TimeLimits map[string]*TimeLimit    `protobuf:"bytes,4,rep,name=timeLimits" json:"timeLimits,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Storage    string                   `protobuf:"bytes,5,opt,name=storage" json:"storage,omitempty"`
}

func (m *Job) Reset()         { *m = Job{} }
func (m *Job) String() string { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()    {}

func (m *Job) GetContainer() *Container {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *Job) GetVolumes() []*Volume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *Job) GetResources() map[string]*Resourcelike {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *Job) GetTimeLimits() map[string]*TimeLimit {
	if m != nil {
		return m.TimeLimits
	}
	return nil
}

// Ограничения на время исполнения и интервал между запусками хука. Все времена в миллисекундах.
// maxExecutionTimeMs - ограничение на время выполнения.
// Интервал между запусками рассчитывается по формуле
// min(maxRestartPeriodMs, minRestartPeriodMs + restartPeriodScaleMs * (restartPeriodBackoff ^ step))
// step считается с 0
type TimeLimit struct {
	RestartPeriodScaleMs uint64 `protobuf:"varint,1,opt,name=restartPeriodScaleMs" json:"restartPeriodScaleMs,omitempty"`
	RestartPeriodBackOff uint64 `protobuf:"varint,2,opt,name=restartPeriodBackOff" json:"restartPeriodBackOff,omitempty"`
	MaxRestartPeriodMs   uint64 `protobuf:"varint,3,opt,name=maxRestartPeriodMs" json:"maxRestartPeriodMs,omitempty"`
	MinRestartPeriodMs   uint64 `protobuf:"varint,4,opt,name=minRestartPeriodMs" json:"minRestartPeriodMs,omitempty"`
	MaxExecutionTimeMs   uint64 `protobuf:"varint,5,opt,name=maxExecutionTimeMs" json:"maxExecutionTimeMs,omitempty"`
}

func (m *TimeLimit) Reset()         { *m = TimeLimit{} }
func (m *TimeLimit) String() string { return proto.CompactTextString(m) }
func (*TimeLimit) ProtoMessage()    {}

// Описание контейнера, в котором запускается хук.
type Container struct {
	// Запрошенные для задачи вычислительные ресурсы.
	// Учитываются при выборе хоста для выполнения задачи.
	// Транслируются в ограничения porto-контейнера для всех хуков.
	ComputingResources *ComputingResources `protobuf:"bytes,1,opt,name=computingResources" json:"computingResources,omitempty"`
	// Уникальный в рамках хоста идентификатор контейнера.
	// Все workload на хосте, у которых контейнер имеет одинаковый идентификатор, выполняются в одном porto-контейнере.
	// Контейнеры с одинаковыми идентификаторами должны обязательно иметь равные поля в рамках одного хоста.
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// Свойства porto-контейнеров хуков, задаваемые непосредственно.
	// Описание формата https://wiki.yandex-team.ru/iss3/specifications/configuration/container/
	Constraints map[string]string `protobuf:"bytes,3,rep,name=constraints" json:"constraints,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Container) Reset()         { *m = Container{} }
func (m *Container) String() string { return proto.CompactTextString(m) }
func (*Container) ProtoMessage()    {}

func (m *Container) GetComputingResources() *ComputingResources {
	if m != nil {
		return m.ComputingResources
	}
	return nil
}

func (m *Container) GetConstraints() map[string]string {
	if m != nil {
		return m.Constraints
	}
	return nil
}

// Уникальный идентификатор задачи
type WorkloadId struct {
	Slot *Slot `protobuf:"bytes,1,opt,name=slot" json:"slot,omitempty"`
	// Название конфигурации в формате <семейство>#<имя конфигурации в семействе>
	Configuration *ConfigurationId `protobuf:"bytes,2,opt,name=configuration" json:"configuration,omitempty"`
}

func (m *WorkloadId) Reset()         { *m = WorkloadId{} }
func (m *WorkloadId) String() string { return proto.CompactTextString(m) }
func (*WorkloadId) ProtoMessage()    {}

func (m *WorkloadId) GetSlot() *Slot {
	if m != nil {
		return m.Slot
	}
	return nil
}

func (m *WorkloadId) GetConfiguration() *ConfigurationId {
	if m != nil {
		return m.Configuration
	}
	return nil
}

// Место под сервис на хосте
// Если две сущности используют один слот, то только одна из них может быть активной в каждый момент времени
type Slot struct {
	// Идентификатор сервиса на хосте, например (но не обязательно), порт
	Service string `protobuf:"bytes,1,opt,name=service" json:"service,omitempty"`
	// FQDN хоста
	Host string `protobuf:"bytes,2,opt,name=host" json:"host,omitempty"`
}

func (m *Slot) Reset()         { *m = Slot{} }
func (m *Slot) String() string { return proto.CompactTextString(m) }
func (*Slot) ProtoMessage()    {}

// Идентификатор конфигурации - описания целевого состояния группы задач.
type ConfigurationId struct {
	// Группа, в которую входит задача - берется из GroupTransition.
	GroupId string `protobuf:"bytes,1,opt,name=groupId" json:"groupId,omitempty"`
	// Идентификатор целевого состояния группы. Произвольная строка.
	GroupStateFingerprint string `protobuf:"bytes,2,opt,name=groupStateFingerprint" json:"groupStateFingerprint,omitempty"`
}

func (m *ConfigurationId) Reset()         { *m = ConfigurationId{} }
func (m *ConfigurationId) String() string { return proto.CompactTextString(m) }
func (*ConfigurationId) ProtoMessage()    {}

// Раздел porto
// Подробное описание здесь https://wiki.yandex-team.ru/iss3/specifications/configuration/instance/volumes/
type Volume struct {
	// Квота на размер корневого раздела
	QuotaBytes uint64 `protobuf:"varint,1,opt,name=quotaBytes" json:"quotaBytes,omitempty"`
	// Квота на размер рабочей директории
	QuotaCwdBytes uint64 `protobuf:"varint,2,opt,name=quotaCwdBytes" json:"quotaCwdBytes,omitempty"`
	// точка монтирования
	MountPoint string `protobuf:"bytes,3,opt,name=mountPoint" json:"mountPoint,omitempty"`
	// Сейчас определено только свойство bind
	// https://wiki.yandex-team.ru/iss3/specifications/configuration/instance/volumes/#polzovatelskijjbind
	Properties map[string]string `protobuf:"bytes,4,rep,name=properties" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Слои, из которых собирается корневой раздел
	Layers []*Resource `protobuf:"bytes,5,rep,name=layers" json:"layers,omitempty"`
	// Указывается при создании shared-volume
	Uuid string `protobuf:"bytes,6,opt,name=uuid" json:"uuid,omitempty"`
	// Точка монтирования, в которой будет создан volume, будут храниться его данные и распаковываться слои.
	// По умолчанию создается под "/", данные хранятся в стандартных директориях porto.
	Storage string `protobuf:"bytes,7,opt,name=storage" json:"storage,omitempty"`
}

func (m *Volume) Reset()         { *m = Volume{} }
func (m *Volume) String() string { return proto.CompactTextString(m) }
func (*Volume) ProtoMessage()    {}

func (m *Volume) GetProperties() map[string]string {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *Volume) GetLayers() []*Resource {
	if m != nil {
		return m.Layers
	}
	return nil
}

// Базовый класс ресурса
type Resourcelike struct {
	Resource        *Resource        `protobuf:"bytes,1,opt,name=resource" json:"resource,omitempty"`
	DynamicResource *DynamicResource `protobuf:"bytes,2,opt,name=dynamicResource" json:"dynamicResource,omitempty"`
	Shard           *Shard           `protobuf:"bytes,3,opt,name=shard" json:"shard,omitempty"`
}

func (m *Resourcelike) Reset()         { *m = Resourcelike{} }
func (m *Resourcelike) String() string { return proto.CompactTextString(m) }
func (*Resourcelike) ProtoMessage()    {}

func (m *Resourcelike) GetResource() *Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *Resourcelike) GetDynamicResource() *DynamicResource {
	if m != nil {
		return m.DynamicResource
	}
	return nil
}

func (m *Resourcelike) GetShard() *Shard {
	if m != nil {
		return m.Shard
	}
	return nil
}

// Обычный ресурс - набор данных
type Resource struct {
	// Уникальный идентификатор (произвольная строка)
	Uuid string `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	// Имя очереди закачки (пустое - качается без очереди)
	// https://wiki.yandex-team.ru/iss3/specifications/agent/downloadqueues/
	Queue        string        `protobuf:"bytes,2,opt,name=queue" json:"queue,omitempty"`
	Verification *Verification `protobuf:"bytes,3,opt,name=verification" json:"verification,omitempty"`
	// Ссылки на реурс, например, "rbtorrent:2f83ff0f5b98b315ce356e129ce1e00d7b67ec7d", "http://cmsearch.yandex.ru/res"
	Urls []string `protobuf:"bytes,4,rep,name=urls" json:"urls,omitempty"`
	// Размер ресурса в байтах
	SizeBytes uint64 `protobuf:"varint,5,opt,name=sizeBytes" json:"sizeBytes,omitempty"`
	// Является ли ресурс закешированным
	// https://wiki.yandex-team.ru/iss3/Specifications/ShardTracker/#upravleniesvobodnymmestom
	Cached bool `protobuf:"varint,6,opt,name=cached" json:"cached,omitempty"`
	// Точка монтирования, в которой будет скачан ресурс (см. Instance.storage)
	Storage string `protobuf:"bytes,7,opt,name=storage" json:"storage,omitempty"`
	// Ограничение скорости закачки
	TrafficClass *TrafficClass `protobuf:"bytes,8,opt,name=trafficClass" json:"trafficClass,omitempty"`
}

func (m *Resource) Reset()         { *m = Resource{} }
func (m *Resource) String() string { return proto.CompactTextString(m) }
func (*Resource) ProtoMessage()    {}

func (m *Resource) GetVerification() *Verification {
	if m != nil {
		return m.Verification
	}
	return nil
}

func (m *Resource) GetTrafficClass() *TrafficClass {
	if m != nil {
		return m.TrafficClass
	}
	return nil
}

// Динамический ресурс
// Может обновляться без перезапуска демона, при обновлении запускается iss_hook_notify
// https://wiki.yandex-team.ru/iss3/specifications/configuration/resource/#dinamicheskijjresurs
// Поля те же, что и у ресурса
type DynamicResource struct {
	Uuid         string        `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	Queue        string        `protobuf:"bytes,2,opt,name=queue" json:"queue,omitempty"`
	Verification *Verification `protobuf:"bytes,3,opt,name=verification" json:"verification,omitempty"`
	Urls         []string      `protobuf:"bytes,4,rep,name=urls" json:"urls,omitempty"`
	SizeBytes    uint64        `protobuf:"varint,5,opt,name=sizeBytes" json:"sizeBytes,omitempty"`
	Cached       bool          `protobuf:"varint,6,opt,name=cached" json:"cached,omitempty"`
	Storage      string        `protobuf:"bytes,7,opt,name=storage" json:"storage,omitempty"`
	// Ограничение скорости закачки
	TrafficClass *TrafficClass `protobuf:"bytes,8,opt,name=trafficClass" json:"trafficClass,omitempty"`
}

func (m *DynamicResource) Reset()         { *m = DynamicResource{} }
func (m *DynamicResource) String() string { return proto.CompactTextString(m) }
func (*DynamicResource) ProtoMessage()    {}

func (m *DynamicResource) GetVerification() *Verification {
	if m != nil {
		return m.Verification
	}
	return nil
}

func (m *DynamicResource) GetTrafficClass() *TrafficClass {
	if m != nil {
		return m.TrafficClass
	}
	return nil
}

// Проверки целостности ресурса
type Verification struct {
	// Контрольная сумма, формат <схема>:<значение> Поддерживаемые схемы "MD5:", "EMPTY:" - case sensitive
	Checksum string `protobuf:"bytes,1,opt,name=checksum" json:"checksum,omitempty"`
	// Периодичность проверки контрольной суммы. При значении 0d0h0m проверка будет выполнена только 1 раз.
	CheckPeriod string `protobuf:"bytes,2,opt,name=checkPeriod" json:"checkPeriod,omitempty"`
}

func (m *Verification) Reset()         { *m = Verification{} }
func (m *Verification) String() string { return proto.CompactTextString(m) }
func (*Verification) ProtoMessage()    {}

// Шард - данные + специальный сценарий подготовки
// Подробности https://wiki.yandex-team.ru/iss3/specifications/shardtracker/
type Shard struct {
	// Уникальный идентификатор шарда
	ShardId string `protobuf:"bytes,1,opt,name=shardId" json:"shardId,omitempty"`
	// Является ли шард закешированным (аналогично ресурсу)
	Cached bool `protobuf:"varint,3,opt,name=cached" json:"cached,omitempty"`
	// Ограничения на хуки шарда. Отличаются от ограничений сущности правилами распределения между хуками
	// TODO: актуализировать после ISS-3052
	Container *Container `protobuf:"bytes,4,opt,name=container" json:"container,omitempty"`
	// Очередь, в которой выполняются закачка, инсталляция и расшаривание (при необходимости) шарда.
	Queue string `protobuf:"bytes,5,opt,name=queue" json:"queue,omitempty"`
	// Режим дедупликации скачиваемых данных скайнетом
	DeduplicationMode DeduplicationMode `protobuf:"varint,6,opt,name=deduplicationMode,enum=DeduplicationMode" json:"deduplicationMode,omitempty"`
	// Точка монтирования, в которой будет скачан и инсталлирован шард (см. Instance.storage)
	Storage string `protobuf:"bytes,7,opt,name=storage" json:"storage,omitempty"`
	// Ограничение скорости закачки
	TrafficClass *TrafficClass `protobuf:"bytes,8,opt,name=trafficClass" json:"trafficClass,omitempty"`
}

func (m *Shard) Reset()         { *m = Shard{} }
func (m *Shard) String() string { return proto.CompactTextString(m) }
func (*Shard) ProtoMessage()    {}

func (m *Shard) GetContainer() *Container {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *Shard) GetTrafficClass() *TrafficClass {
	if m != nil {
		return m.TrafficClass
	}
	return nil
}

type TrafficClass struct {
	DownloadSpeedLimit int64  `protobuf:"varint,1,opt,name=downloadSpeedLimit" json:"downloadSpeedLimit,omitempty"`
	TrafficTag         string `protobuf:"bytes,2,opt,name=trafficTag" json:"trafficTag,omitempty"`
}

func (m *TrafficClass) Reset()         { *m = TrafficClass{} }
func (m *TrafficClass) String() string { return proto.CompactTextString(m) }
func (*TrafficClass) ProtoMessage()    {}

// Текущее состояние сущности
type DetailedCurrentState struct {
	WorkloadId *WorkloadId `protobuf:"bytes,1,opt,name=workloadId" json:"workloadId,omitempty"`
	// Строковое описание состояния, может принимать произвольные значения, в том числе весь список целевых состояний
	CurrentState string                `protobuf:"bytes,2,opt,name=currentState" json:"currentState,omitempty"`
	Feedback     *CurrentStateFeedback `protobuf:"bytes,3,opt,name=feedback" json:"feedback,omitempty"`
	// Момент отправки сообщения с агента
	HostTimestamp uint64 `protobuf:"varint,4,opt,name=hostTimestamp" json:"hostTimestamp,omitempty"`
	// Момент сохранения сообщения сервером
	ServerTimestamp uint64 `protobuf:"varint,5,opt,name=serverTimestamp" json:"serverTimestamp,omitempty"`
}

func (m *DetailedCurrentState) Reset()         { *m = DetailedCurrentState{} }
func (m *DetailedCurrentState) String() string { return proto.CompactTextString(m) }
func (*DetailedCurrentState) ProtoMessage()    {}

func (m *DetailedCurrentState) GetWorkloadId() *WorkloadId {
	if m != nil {
		return m.WorkloadId
	}
	return nil
}

func (m *DetailedCurrentState) GetFeedback() *CurrentStateFeedback {
	if m != nil {
		return m.Feedback
	}
	return nil
}

type CurrentStateFeedback struct {
	// Поле для служебных сообщений в случае проблем с сохранением (например, слишком большое сообщение)
	SpecialMessage string `protobuf:"bytes,1,opt,name=specialMessage" json:"specialMessage,omitempty"`
	// porto-метрики
	Metrics []*FeedbackMessage `protobuf:"bytes,2,rep,name=metrics" json:"metrics,omitempty"`
	// сообщения о незавершенных операциях
	PendingStateMessages []*FeedbackMessage `protobuf:"bytes,3,rep,name=pendingStateMessages" json:"pendingStateMessages,omitempty"`
	Info                 []*FeedbackMessage `protobuf:"bytes,4,rep,name=info" json:"info,omitempty"`
	Warnings             []*FeedbackMessage `protobuf:"bytes,5,rep,name=warnings" json:"warnings,omitempty"`
	Failures             []*FeedbackMessage `protobuf:"bytes,6,rep,name=failures" json:"failures,omitempty"`
}

func (m *CurrentStateFeedback) Reset()         { *m = CurrentStateFeedback{} }
func (m *CurrentStateFeedback) String() string { return proto.CompactTextString(m) }
func (*CurrentStateFeedback) ProtoMessage()    {}

func (m *CurrentStateFeedback) GetMetrics() []*FeedbackMessage {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *CurrentStateFeedback) GetPendingStateMessages() []*FeedbackMessage {
	if m != nil {
		return m.PendingStateMessages
	}
	return nil
}

func (m *CurrentStateFeedback) GetInfo() []*FeedbackMessage {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *CurrentStateFeedback) GetWarnings() []*FeedbackMessage {
	if m != nil {
		return m.Warnings
	}
	return nil
}

func (m *CurrentStateFeedback) GetFailures() []*FeedbackMessage {
	if m != nil {
		return m.Failures
	}
	return nil
}

// Отдельное сообщение обратной связи от агента
type FeedbackMessage struct {
	CountersFeedback            *CountersFeedback            `protobuf:"bytes,1,opt,name=countersFeedback" json:"countersFeedback,omitempty"`
	FeedbackMergeMessage        *FeedbackMergeMessage        `protobuf:"bytes,2,opt,name=feedbackMergeMessage" json:"feedbackMergeMessage,omitempty"`
	FeedbackOkMessage           *FeedbackOkMessage           `protobuf:"bytes,3,opt,name=feedbackOkMessage" json:"feedbackOkMessage,omitempty"`
	Progress                    *Progress                    `protobuf:"bytes,4,opt,name=progress" json:"progress,omitempty"`
	Lock                        *Lock                        `protobuf:"bytes,6,opt,name=lock" json:"lock,omitempty"`
	ProcessFeedback             *ProcessFeedback             `protobuf:"bytes,7,opt,name=processFeedback" json:"processFeedback,omitempty"`
	SelfHelp                    *SelfHelp                    `protobuf:"bytes,8,opt,name=selfHelp" json:"selfHelp,omitempty"`
	ChecksumVerificationFailure *ChecksumVerificationFailure `protobuf:"bytes,9,opt,name=checksumVerificationFailure" json:"checksumVerificationFailure,omitempty"`
	ChecksumProgress            *ChecksumProgress            `protobuf:"bytes,10,opt,name=checksumProgress" json:"checksumProgress,omitempty"`
	DaemonFailure               *DaemonFailure               `protobuf:"bytes,11,opt,name=daemonFailure" json:"daemonFailure,omitempty"`
	DownloadFailed              *DownloadFailed              `protobuf:"bytes,12,opt,name=downloadFailed" json:"downloadFailed,omitempty"`
	ResourcesNotReady           *ResourcesNotReady           `protobuf:"bytes,13,opt,name=resourcesNotReady" json:"resourcesNotReady,omitempty"`
	ValidationFailed            *ValidationFailed            `protobuf:"bytes,14,opt,name=validationFailed" json:"validationFailed,omitempty"`
	DirectoryFailure            *DirectoryFailure            `protobuf:"bytes,15,opt,name=directoryFailure" json:"directoryFailure,omitempty"`
	CachedResourceNotRemoved    *CachedResourceNotRemoved    `protobuf:"bytes,16,opt,name=cachedResourceNotRemoved" json:"cachedResourceNotRemoved,omitempty"`
	WaitingForFreeSpace         *WaitingForFreeSpace         `protobuf:"bytes,17,opt,name=waitingForFreeSpace" json:"waitingForFreeSpace,omitempty"`
	HookFailure                 *HookFailure                 `protobuf:"bytes,18,opt,name=hookFailure" json:"hookFailure,omitempty"`
	CountLimit                  *CountLimit                  `protobuf:"bytes,20,opt,name=countLimit" json:"countLimit,omitempty"`
	FrequencyLimit              *FrequencyLimit              `protobuf:"bytes,21,opt,name=frequencyLimit" json:"frequencyLimit,omitempty"`
	PendingRemove               *PendingDriverRemove         `protobuf:"bytes,22,opt,name=pendingRemove" json:"pendingRemove,omitempty"`
	TimeLimitViolation          *TimeLimitViolation          `protobuf:"bytes,23,opt,name=timeLimitViolation" json:"timeLimitViolation,omitempty"`
	ShardFailure                *ShardFailure                `protobuf:"bytes,25,opt,name=shardFailure" json:"shardFailure,omitempty"`
	FailMessage                 *FeedbackFailMessage         `protobuf:"bytes,27,opt,name=failMessage" json:"failMessage,omitempty"`
	HookInProgress              *HookInProgress              `protobuf:"bytes,28,opt,name=hookInProgress" json:"hookInProgress,omitempty"`
}

func (m *FeedbackMessage) Reset()         { *m = FeedbackMessage{} }
func (m *FeedbackMessage) String() string { return proto.CompactTextString(m) }
func (*FeedbackMessage) ProtoMessage()    {}

func (m *FeedbackMessage) GetCountersFeedback() *CountersFeedback {
	if m != nil {
		return m.CountersFeedback
	}
	return nil
}

func (m *FeedbackMessage) GetFeedbackMergeMessage() *FeedbackMergeMessage {
	if m != nil {
		return m.FeedbackMergeMessage
	}
	return nil
}

func (m *FeedbackMessage) GetFeedbackOkMessage() *FeedbackOkMessage {
	if m != nil {
		return m.FeedbackOkMessage
	}
	return nil
}

func (m *FeedbackMessage) GetProgress() *Progress {
	if m != nil {
		return m.Progress
	}
	return nil
}

func (m *FeedbackMessage) GetLock() *Lock {
	if m != nil {
		return m.Lock
	}
	return nil
}

func (m *FeedbackMessage) GetProcessFeedback() *ProcessFeedback {
	if m != nil {
		return m.ProcessFeedback
	}
	return nil
}

func (m *FeedbackMessage) GetSelfHelp() *SelfHelp {
	if m != nil {
		return m.SelfHelp
	}
	return nil
}

func (m *FeedbackMessage) GetChecksumVerificationFailure() *ChecksumVerificationFailure {
	if m != nil {
		return m.ChecksumVerificationFailure
	}
	return nil
}

func (m *FeedbackMessage) GetChecksumProgress() *ChecksumProgress {
	if m != nil {
		return m.ChecksumProgress
	}
	return nil
}

func (m *FeedbackMessage) GetDaemonFailure() *DaemonFailure {
	if m != nil {
		return m.DaemonFailure
	}
	return nil
}

func (m *FeedbackMessage) GetDownloadFailed() *DownloadFailed {
	if m != nil {
		return m.DownloadFailed
	}
	return nil
}

func (m *FeedbackMessage) GetResourcesNotReady() *ResourcesNotReady {
	if m != nil {
		return m.ResourcesNotReady
	}
	return nil
}

func (m *FeedbackMessage) GetValidationFailed() *ValidationFailed {
	if m != nil {
		return m.ValidationFailed
	}
	return nil
}

func (m *FeedbackMessage) GetDirectoryFailure() *DirectoryFailure {
	if m != nil {
		return m.DirectoryFailure
	}
	return nil
}

func (m *FeedbackMessage) GetCachedResourceNotRemoved() *CachedResourceNotRemoved {
	if m != nil {
		return m.CachedResourceNotRemoved
	}
	return nil
}

func (m *FeedbackMessage) GetWaitingForFreeSpace() *WaitingForFreeSpace {
	if m != nil {
		return m.WaitingForFreeSpace
	}
	return nil
}

func (m *FeedbackMessage) GetHookFailure() *HookFailure {
	if m != nil {
		return m.HookFailure
	}
	return nil
}

func (m *FeedbackMessage) GetCountLimit() *CountLimit {
	if m != nil {
		return m.CountLimit
	}
	return nil
}

func (m *FeedbackMessage) GetFrequencyLimit() *FrequencyLimit {
	if m != nil {
		return m.FrequencyLimit
	}
	return nil
}

func (m *FeedbackMessage) GetPendingRemove() *PendingDriverRemove {
	if m != nil {
		return m.PendingRemove
	}
	return nil
}

func (m *FeedbackMessage) GetTimeLimitViolation() *TimeLimitViolation {
	if m != nil {
		return m.TimeLimitViolation
	}
	return nil
}

func (m *FeedbackMessage) GetShardFailure() *ShardFailure {
	if m != nil {
		return m.ShardFailure
	}
	return nil
}

func (m *FeedbackMessage) GetFailMessage() *FeedbackFailMessage {
	if m != nil {
		return m.FailMessage
	}
	return nil
}

func (m *FeedbackMessage) GetHookInProgress() *HookInProgress {
	if m != nil {
		return m.HookInProgress
	}
	return nil
}

// Базовое сообщение для всех поломок
type FeedbackFailMessage struct {
	// Тип проблемы, например, HOOK_FAILED
	State string `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	// Подробное описание
	FailReason string `protobuf:"bytes,2,opt,name=failReason" json:"failReason,omitempty"`
}

func (m *FeedbackFailMessage) Reset()         { *m = FeedbackFailMessage{} }
func (m *FeedbackFailMessage) String() string { return proto.CompactTextString(m) }
func (*FeedbackFailMessage) ProtoMessage()    {}

// Хук в процессе выполнения
type HookInProgress struct {
	State string `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	// Имя хука
	Hook string `protobuf:"bytes,2,opt,name=hook" json:"hook,omitempty"`
	// true сразу после запуска агента, false если агент рапортует об уже работающем хуке
	JustCreated bool `protobuf:"varint,3,opt,name=justCreated" json:"justCreated,omitempty"`
}

func (m *HookInProgress) Reset()         { *m = HookInProgress{} }
func (m *HookInProgress) String() string { return proto.CompactTextString(m) }
func (*HookInProgress) ProtoMessage()    {}

// Счетчики от порто
type CountersFeedback struct {
	State     string            `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	Counters  map[string]string `protobuf:"bytes,2,rep,name=counters" json:"counters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Timestamp uint64            `protobuf:"varint,3,opt,name=timestamp" json:"timestamp,omitempty"`
	Container string            `protobuf:"bytes,4,opt,name=container" json:"container,omitempty"`
}

func (m *CountersFeedback) Reset()         { *m = CountersFeedback{} }
func (m *CountersFeedback) String() string { return proto.CompactTextString(m) }
func (*CountersFeedback) ProtoMessage()    {}

func (m *CountersFeedback) GetCounters() map[string]string {
	if m != nil {
		return m.Counters
	}
	return nil
}

// Информация о слиянии в агенте данных, полученных из разных кешеров
type FeedbackMergeMessage struct {
	State string `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
}

func (m *FeedbackMergeMessage) Reset()         { *m = FeedbackMergeMessage{} }
func (m *FeedbackMergeMessage) String() string { return proto.CompactTextString(m) }
func (*FeedbackMergeMessage) ProtoMessage()    {}

type FeedbackOkMessage struct {
	State string `protobuf:"bytes,2,opt,name=state" json:"state,omitempty"`
}

func (m *FeedbackOkMessage) Reset()         { *m = FeedbackOkMessage{} }
func (m *FeedbackOkMessage) String() string { return proto.CompactTextString(m) }
func (*FeedbackOkMessage) ProtoMessage()    {}

// Идет скачивание данных
type Progress struct {
	// Ссылка, по которой качается
	From string `protobuf:"bytes,1,opt,name=from" json:"from,omitempty"`
	// Целевая директория
	To         string `protobuf:"bytes,2,opt,name=to" json:"to,omitempty"`
	BytesDone  uint64 `protobuf:"varint,3,opt,name=bytesDone" json:"bytesDone,omitempty"`
	BytesTotal uint64 `protobuf:"varint,4,opt,name=bytesTotal" json:"bytesTotal,omitempty"`
	State      string `protobuf:"bytes,5,opt,name=state" json:"state,omitempty"`
}

func (m *Progress) Reset()         { *m = Progress{} }
func (m *Progress) String() string { return proto.CompactTextString(m) }
func (*Progress) ProtoMessage()    {}

// Операция не смогла взять блокировку (например, для очереди закачки)
type Lock struct {
	State string `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	// Имя блокировки
	Lock string `protobuf:"bytes,2,opt,name=lock" json:"lock,omitempty"`
	// Текущий владелец блокировки
	LockedBy string `protobuf:"bytes,3,opt,name=lockedBy" json:"lockedBy,omitempty"`
	// Драйвер, который заблокировался
	RequestedBy string `protobuf:"bytes,4,opt,name=requestedBy" json:"requestedBy,omitempty"`
}

func (m *Lock) Reset()         { *m = Lock{} }
func (m *Lock) String() string { return proto.CompactTextString(m) }
func (*Lock) ProtoMessage()    {}

// Завершение процесса
type ProcessFeedback struct {
	// DAEMON_EXITED - старт-хук демона завершился с кодом 0
	// DAEMON_WAS_TERMINATED_EXTERNALLY - старт-хук демона завершился с кодом не-0
	// HOOK_CANCELLED - хук/задачу убили 9-кой
	// HOOK_FAILED - хук/задача завершились самостоятельно с кодом 1-31
	// HOOK_SEMI_FAILED - хук упал с кодом 32-63
	// HOOK_EXITED - хук/задача завершились с кодом 0
	// Подробности про коды https://wiki.yandex-team.ru/iss3/specifications/configuration/instance/#naznacheniexukov
	State string `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	// Имя завершившегося хука
	ExecutableName string `protobuf:"bytes,2,opt,name=executableName" json:"executableName,omitempty"`
	// Хвост stdout
	StdOut string `protobuf:"bytes,3,opt,name=stdOut" json:"stdOut,omitempty"`
	// Хвост stderr
	StdErr string `protobuf:"bytes,4,opt,name=stdErr" json:"stdErr,omitempty"`
	// Код завершения процесса
	ExitCode uint32 `protobuf:"varint,5,opt,name=exitCode" json:"exitCode,omitempty"`
	// Номер сигнала, по которому завершился процесс.
	// Темная магия агента старается обработать случай, когда процесс является шеллом
	// и сигнализирует о завершении дочернего процесса по сигналу согласно http://www.tldp.org/LDP/abs/html/exitcodes.html
	SignalNumber uint32 `protobuf:"varint,6,opt,name=signalNumber" json:"signalNumber,omitempty"`
	// Был ли процесс завершен из-за нехватки памяти
	OutOfMemory bool `protobuf:"varint,7,opt,name=outOfMemory" json:"outOfMemory,omitempty"`
}

func (m *ProcessFeedback) Reset()         { *m = ProcessFeedback{} }
func (m *ProcessFeedback) String() string { return proto.CompactTextString(m) }
func (*ProcessFeedback) ProtoMessage()    {}

// Отладочное сообщение
type SelfHelp struct {
	Cause string `protobuf:"bytes,1,opt,name=cause" json:"cause,omitempty"`
	// Ссылка на ресурс, послуживший причиной
	Url string `protobuf:"bytes,2,opt,name=url" json:"url,omitempty"`
	// Локальное имя файла
	LocalName string `protobuf:"bytes,3,opt,name=localName" json:"localName,omitempty"`
	// Затронутые сущности
	Affected    []string `protobuf:"bytes,4,rep,name=affected" json:"affected,omitempty"`
	CustomLines string   `protobuf:"bytes,5,opt,name=customLines" json:"customLines,omitempty"`
	State       string   `protobuf:"bytes,6,opt,name=state" json:"state,omitempty"`
}

func (m *SelfHelp) Reset()         { *m = SelfHelp{} }
func (m *SelfHelp) String() string { return proto.CompactTextString(m) }
func (*SelfHelp) ProtoMessage()    {}

// Контрольная сумма ресурса не совпала с ожидаемой
type ChecksumVerificationFailure struct {
	State      string `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	Expected   string `protobuf:"bytes,2,opt,name=expected" json:"expected,omitempty"`
	Calculated string `protobuf:"bytes,3,opt,name=calculated" json:"calculated,omitempty"`
	TargetFile string `protobuf:"bytes,4,opt,name=targetFile" json:"targetFile,omitempty"`
}

func (m *ChecksumVerificationFailure) Reset()         { *m = ChecksumVerificationFailure{} }
func (m *ChecksumVerificationFailure) String() string { return proto.CompactTextString(m) }
func (*ChecksumVerificationFailure) ProtoMessage()    {}

// Идет вычисление контрольной суммы
type ChecksumProgress struct {
	State      string `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	TargetFile string `protobuf:"bytes,2,opt,name=targetFile" json:"targetFile,omitempty"`
}

func (m *ChecksumProgress) Reset()         { *m = ChecksumProgress{} }
func (m *ChecksumProgress) String() string { return proto.CompactTextString(m) }
func (*ChecksumProgress) ProtoMessage()    {}

// Прочие проблемы со старт-хуком
type DaemonFailure struct {
	State      string `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	FailReason string `protobuf:"bytes,3,opt,name=failReason" json:"failReason,omitempty"`
	Hook       string `protobuf:"bytes,4,opt,name=hook" json:"hook,omitempty"`
}

func (m *DaemonFailure) Reset()         { *m = DaemonFailure{} }
func (m *DaemonFailure) String() string { return proto.CompactTextString(m) }
func (*DaemonFailure) ProtoMessage()    {}

// Скачивание ресурса завершилось с ошибкой
type DownloadFailed struct {
	State      string `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	FailReason string `protobuf:"bytes,3,opt,name=failReason" json:"failReason,omitempty"`
	// Ссылка на ресурс
	From string `protobuf:"bytes,4,opt,name=from" json:"from,omitempty"`
	// Путь к результату скачивания
	To string `protobuf:"bytes,5,opt,name=to" json:"to,omitempty"`
}

func (m *DownloadFailed) Reset()         { *m = DownloadFailed{} }
func (m *DownloadFailed) String() string { return proto.CompactTextString(m) }
func (*DownloadFailed) ProtoMessage()    {}

// Ресурсы сущности не готовы
type ResourcesNotReady struct {
	State string `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	// <имя не готового ресурса> -> <текущее состояние>
	States     map[string]string `protobuf:"bytes,2,rep,name=states" json:"states,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	FailReason string            `protobuf:"bytes,4,opt,name=failReason" json:"failReason,omitempty"`
}

func (m *ResourcesNotReady) Reset()         { *m = ResourcesNotReady{} }
func (m *ResourcesNotReady) String() string { return proto.CompactTextString(m) }
func (*ResourcesNotReady) ProtoMessage()    {}

func (m *ResourcesNotReady) GetStates() map[string]string {
	if m != nil {
		return m.States
	}
	return nil
}

// Не удалось проверить контрольную сумму ресурса
type ValidationFailed struct {
	State      string `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	FailReason string `protobuf:"bytes,3,opt,name=failReason" json:"failReason,omitempty"`
	// Отсутствующий файл ресурса
	MissingFile string `protobuf:"bytes,4,opt,name=missingFile" json:"missingFile,omitempty"`
	// Директория, в которой должен находиться файл
	TargetDir string `protobuf:"bytes,5,opt,name=targetDir" json:"targetDir,omitempty"`
	// Ссылка на ресурс
	From string `protobuf:"bytes,6,opt,name=from" json:"from,omitempty"`
	// Путь к результату скачивания
	To string `protobuf:"bytes,7,opt,name=to" json:"to,omitempty"`
}

func (m *ValidationFailed) Reset()         { *m = ValidationFailed{} }
func (m *ValidationFailed) String() string { return proto.CompactTextString(m) }
func (*ValidationFailed) ProtoMessage()    {}

// Ошибка в агенте при работе с директориями
type DirectoryFailure struct {
	State      string `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	FailReason string `protobuf:"bytes,3,opt,name=failReason" json:"failReason,omitempty"`
	Directory  string `protobuf:"bytes,4,opt,name=directory" json:"directory,omitempty"`
}

func (m *DirectoryFailure) Reset()         { *m = DirectoryFailure{} }
func (m *DirectoryFailure) String() string { return proto.CompactTextString(m) }
func (*DirectoryFailure) ProtoMessage()    {}

// Ресурс не удален, т.к. выставлено свойство cached = true
type CachedResourceNotRemoved struct {
	State string `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	// Свободное место в байтах
	AvailableBytes uint64 `protobuf:"varint,4,opt,name=availableBytes" json:"availableBytes,omitempty"`
	// Нижняя граница свободного места в байтах
	SpaceToLeaveOnDiskBytes uint64 `protobuf:"varint,5,opt,name=spaceToLeaveOnDiskBytes" json:"spaceToLeaveOnDiskBytes,omitempty"`
	// Драйвер, владеющий резервацией
	Reserver string `protobuf:"bytes,6,opt,name=reserver" json:"reserver,omitempty"`
}

func (m *CachedResourceNotRemoved) Reset()         { *m = CachedResourceNotRemoved{} }
func (m *CachedResourceNotRemoved) String() string { return proto.CompactTextString(m) }
func (*CachedResourceNotRemoved) ProtoMessage()    {}

// Ресурс ожидает свободного места на диске
type WaitingForFreeSpace struct {
	State string `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	// Драйвер, запрашивающий резервацию
	Reserver string `protobuf:"bytes,4,opt,name=reserver" json:"reserver,omitempty"`
	// Запрашиваемое место в байтах
	RequiredBytes uint64 `protobuf:"varint,5,opt,name=requiredBytes" json:"requiredBytes,omitempty"`
	// Уже занятое место в байтах (например, ресурс частично скачался, потом агент перезапустился)
	ConsumedBytes uint64 `protobuf:"varint,6,opt,name=consumedBytes" json:"consumedBytes,omitempty"`
	// Размер дискового раздела в байтах
	TotalBytes uint64 `protobuf:"varint,7,opt,name=totalBytes" json:"totalBytes,omitempty"`
	// Доступное место в байтах
	AvailableBytes uint64 `protobuf:"varint,8,opt,name=availableBytes" json:"availableBytes,omitempty"`
	// Нижняя граница свободного места в байтах
	SpaceToLeaveOnDiskBytes uint64 `protobuf:"varint,9,opt,name=spaceToLeaveOnDiskBytes" json:"spaceToLeaveOnDiskBytes,omitempty"`
}

func (m *WaitingForFreeSpace) Reset()         { *m = WaitingForFreeSpace{} }
func (m *WaitingForFreeSpace) String() string { return proto.CompactTextString(m) }
func (*WaitingForFreeSpace) ProtoMessage()    {}

// Ошибка операции над хуком (например, не найден файл хука, потерялся контейнер)
type HookFailure struct {
	State string `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	// Имя хука
	Hook string `protobuf:"bytes,4,opt,name=hook" json:"hook,omitempty"`
}

func (m *HookFailure) Reset()         { *m = HookFailure{} }
func (m *HookFailure) String() string { return proto.CompactTextString(m) }
func (*HookFailure) ProtoMessage()    {}

// Внутренняя логика - нарушено ограничение на число повторений операции
type CountLimit struct {
	State string `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	// Разрешенное число повторений
	MaxAttempts uint32 `protobuf:"varint,4,opt,name=maxAttempts" json:"maxAttempts,omitempty"`
	// Текущее число повторений
	Attempts uint32 `protobuf:"varint,5,opt,name=attempts" json:"attempts,omitempty"`
}

func (m *CountLimit) Reset()         { *m = CountLimit{} }
func (m *CountLimit) String() string { return proto.CompactTextString(m) }
func (*CountLimit) ProtoMessage()    {}

// Внутренняя логика - нарушено ограничение на частоту запуска операции
type FrequencyLimit struct {
	State string `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	// Время последнего запуска
	LastRun string `protobuf:"bytes,4,opt,name=lastRun" json:"lastRun,omitempty"`
	// Время возникновения ошибки
	Now string `protobuf:"bytes,5,opt,name=now" json:"now,omitempty"`
	// Разрешенный интервал между запусками
	InvocationGap string `protobuf:"bytes,6,opt,name=invocationGap" json:"invocationGap,omitempty"`
}

func (m *FrequencyLimit) Reset()         { *m = FrequencyLimit{} }
func (m *FrequencyLimit) String() string { return proto.CompactTextString(m) }
func (*FrequencyLimit) ProtoMessage()    {}

// Драйвер не может быть удален, так как на него еще есть ссылки
type PendingDriverRemove struct {
	State string `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	// Удаляемый драйвер
	Id string `protobuf:"bytes,4,opt,name=id" json:"id,omitempty"`
	// Удаляющий драйвер
	RequesterId string `protobuf:"bytes,5,opt,name=requesterId" json:"requesterId,omitempty"`
	// Класс удаляемого драйвера
	Clazz string `protobuf:"bytes,6,opt,name=clazz" json:"clazz,omitempty"`
	// Строковое описание удаляемого драйвера
	Payload string `protobuf:"bytes,7,opt,name=payload" json:"payload,omitempty"`
}

func (m *PendingDriverRemove) Reset()         { *m = PendingDriverRemove{} }
func (m *PendingDriverRemove) String() string { return proto.CompactTextString(m) }
func (*PendingDriverRemove) ProtoMessage()    {}

// Внутренняя логика - нарушено ограничение на время выполнения операции
type TimeLimitViolation struct {
	State string `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	// Время запуска
	FirstRun string `protobuf:"bytes,4,opt,name=firstRun" json:"firstRun,omitempty"`
	// Ограничение на время выполнения
	Duration string `protobuf:"bytes,5,opt,name=duration" json:"duration,omitempty"`
	// Время, прошедшее с момента запуска
	DurationFromFirstRun string `protobuf:"bytes,6,opt,name=durationFromFirstRun" json:"durationFromFirstRun,omitempty"`
}

func (m *TimeLimitViolation) Reset()         { *m = TimeLimitViolation{} }
func (m *TimeLimitViolation) String() string { return proto.CompactTextString(m) }
func (*TimeLimitViolation) ProtoMessage()    {}

// Ошибка при подготовке шарда
type ShardFailure struct {
	State      string `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	FailReason string `protobuf:"bytes,3,opt,name=failReason" json:"failReason,omitempty"`
	ShardId    string `protobuf:"bytes,4,opt,name=shardId" json:"shardId,omitempty"`
}

func (m *ShardFailure) Reset()         { *m = ShardFailure{} }
func (m *ShardFailure) String() string { return proto.CompactTextString(m) }
func (*ShardFailure) ProtoMessage()    {}

type QueueControl struct {
	BlockedDownload bool `protobuf:"varint,1,opt,name=blockedDownload" json:"blockedDownload,omitempty"`
}

func (m *QueueControl) Reset()         { *m = QueueControl{} }
func (m *QueueControl) String() string { return proto.CompactTextString(m) }
func (*QueueControl) ProtoMessage()    {}

type ToAgent struct {
	KeepAlive         *KeepAlive         `protobuf:"bytes,1,opt,name=keepAlive" json:"keepAlive,omitempty"`
	HostConfiguration *HostConfiguration `protobuf:"bytes,2,opt,name=hostConfiguration" json:"hostConfiguration,omitempty"`
}

func (m *ToAgent) Reset()         { *m = ToAgent{} }
func (m *ToAgent) String() string { return proto.CompactTextString(m) }
func (*ToAgent) ProtoMessage()    {}

func (m *ToAgent) GetKeepAlive() *KeepAlive {
	if m != nil {
		return m.KeepAlive
	}
	return nil
}

func (m *ToAgent) GetHostConfiguration() *HostConfiguration {
	if m != nil {
		return m.HostConfiguration
	}
	return nil
}

type ToServer struct {
	Handshake    *AgentHandshake       `protobuf:"bytes,1,opt,name=handshake" json:"handshake,omitempty"`
	KeepAlive    *KeepAlive            `protobuf:"bytes,2,opt,name=keepAlive" json:"keepAlive,omitempty"`
	CurrentState *DetailedCurrentState `protobuf:"bytes,3,opt,name=currentState" json:"currentState,omitempty"`
}

func (m *ToServer) Reset()         { *m = ToServer{} }
func (m *ToServer) String() string { return proto.CompactTextString(m) }
func (*ToServer) ProtoMessage()    {}

func (m *ToServer) GetHandshake() *AgentHandshake {
	if m != nil {
		return m.Handshake
	}
	return nil
}

func (m *ToServer) GetKeepAlive() *KeepAlive {
	if m != nil {
		return m.KeepAlive
	}
	return nil
}

func (m *ToServer) GetCurrentState() *DetailedCurrentState {
	if m != nil {
		return m.CurrentState
	}
	return nil
}

// Целевое состояние хоста и агента
type HostConfiguration struct {
	Instances []*HostConfigurationInstance `protobuf:"bytes,1,rep,name=instances" json:"instances,omitempty"`
}

func (m *HostConfiguration) Reset()         { *m = HostConfiguration{} }
func (m *HostConfiguration) String() string { return proto.CompactTextString(m) }
func (*HostConfiguration) ProtoMessage()    {}

func (m *HostConfiguration) GetInstances() []*HostConfigurationInstance {
	if m != nil {
		return m.Instances
	}
	return nil
}

// Обертка для job/instance
type HostConfigurationInstance struct {
	Id     *WorkloadId `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Entity *Entity     `protobuf:"bytes,2,opt,name=entity" json:"entity,omitempty"`
	// Пользовательские свойства
	// Пробрасываются хукам через переменные среды
	Properties map[string]string `protobuf:"bytes,3,rep,name=properties" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Целевое состояние - одно из "ACTIVE", "PREPARED", "REMOVED"
	TargetState string `protobuf:"bytes,4,opt,name=targetState" json:"targetState,omitempty"`
	// Момент задания целевого состояния в формате UNIX timestamp
	TransitionTimestamp uint64 `protobuf:"varint,5,opt,name=transitionTimestamp" json:"transitionTimestamp,omitempty"`
}

func (m *HostConfigurationInstance) Reset()         { *m = HostConfigurationInstance{} }
func (m *HostConfigurationInstance) String() string { return proto.CompactTextString(m) }
func (*HostConfigurationInstance) ProtoMessage()    {}

func (m *HostConfigurationInstance) GetId() *WorkloadId {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *HostConfigurationInstance) GetEntity() *Entity {
	if m != nil {
		return m.Entity
	}
	return nil
}

func (m *HostConfigurationInstance) GetProperties() map[string]string {
	if m != nil {
		return m.Properties
	}
	return nil
}

// Сообщение, отправляемое агентом при установлении соединения
type AgentHandshake struct {
	Fqdn string `protobuf:"bytes,1,opt,name=fqdn" json:"fqdn,omitempty"`
}

func (m *AgentHandshake) Reset()         { *m = AgentHandshake{} }
func (m *AgentHandshake) String() string { return proto.CompactTextString(m) }
func (*AgentHandshake) ProtoMessage()    {}

// Сообщение для поддержания живости соединения
type KeepAlive struct {
}

func (m *KeepAlive) Reset()         { *m = KeepAlive{} }
func (m *KeepAlive) String() string { return proto.CompactTextString(m) }
func (*KeepAlive) ProtoMessage()    {}

var E_FilterRoot = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.MessageOptions)(nil),
	ExtensionType: (*FilterType)(nil),
	Field:         76123,
	Name:          "filter_root",
	Tag:           "varint,76123,opt,name=filter_root,enum=FilterType",
}

var E_Filterable = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         76123,
	Name:          "filterable",
	Tag:           "varint,76123,opt,name=filterable",
}

var E_Triggerable = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         76124,
	Name:          "triggerable",
	Tag:           "varint,76124,opt,name=triggerable",
}

func init() {
	proto.RegisterEnum("FilterType", FilterType_name, FilterType_value)
	proto.RegisterEnum("HostHealthState", HostHealthState_name, HostHealthState_value)
	proto.RegisterEnum("GpuType", GpuType_name, GpuType_value)
	proto.RegisterEnum("DeduplicationMode", DeduplicationMode_name, DeduplicationMode_value)
	proto.RegisterExtension(E_FilterRoot)
	proto.RegisterExtension(E_Filterable)
	proto.RegisterExtension(E_Triggerable)
}
